<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Announcements Ticker</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: transparent;
      font-family: Arial, sans-serif;
      font-size: 2rem;
      white-space: nowrap;
    }

    .ticker-wrapper {
      position: absolute;
      top: 33vh;
      width: 100%;
    }

    .ticker-container {
      width: 100%;
      position: relative;
      overflow: hidden;
    }

    .ticker {
      display: flex;
      align-items: center;
      will-change: transform;
    }

    .item {
      margin-right: 4rem;
      flex-shrink: 0;
      display: inline-block;
    }

    .item:empty {
      display: none;
    }

    .item.emoji {
      font-size: 2.6rem;
      margin-right: 3rem;
    }

    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5rem;
      color: #666;
    }

    .controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.95);
      padding: 15px 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      z-index: 1000;
      min-width: 250px;
    }

    .controls-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 0.9rem;
      font-weight: bold;
      color: #333;
    }

    .toggle-btn {
      background: none;
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
      padding: 0;
      color: #666;
    }

    .controls-content {
      font-size: 0.85rem;
    }

    .control-group {
      margin-bottom: 12px;
    }

    .control-label {
      display: block;
      color: #555;
      margin-bottom: 5px;
      font-weight: 500;
    }

    .speed-slider {
      width: 100%;
      margin-bottom: 5px;
    }

    .speed-value {
      text-align: center;
      color: #666;
      font-size: 0.8rem;
    }

    .status {
      padding: 8px;
      background: #e8f5e9;
      border-radius: 5px;
      font-size: 0.8rem;
      color: #2e7d32;
      margin-bottom: 10px;
      text-align: center;
    }

    .status.fetching {
      background: #fff3e0;
      color: #e65100;
    }

    .controls.minimized .controls-content {
      display: none;
    }

    .error {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.2rem;
      color: #d32f2f;
      text-align: center;
      max-width: 80%;
    }

    .debug-panel {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.95);
      color: white;
      padding: 20px;
      max-height: 40vh;
      overflow-y: auto;
      border-top: 3px solid #4285f4;
      font-size: 0.75rem;
    }

    .debug-panel h2 {
      margin: 0 0 15px 0;
      font-size: 1rem;
      color: #4285f4;
    }

    .debug-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
    }

    .debug-column {
      background: rgba(255, 255, 255, 0.1);
      padding: 15px;
      border-radius: 5px;
    }

    .debug-column h3 {
      margin: 0 0 10px 0;
      font-size: 0.85rem;
      color: #ffd700;
      border-bottom: 1px solid rgba(255, 255, 255, 0.3);
      padding-bottom: 5px;
    }

    .message-list {
      max-height: 200px;
      overflow-y: auto;
    }

    .message-item {
      padding: 8px;
      margin-bottom: 5px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 3px;
      border-left: 3px solid #4285f4;
      font-size: 0.7rem;
      line-height: 1.4;
    }

    .message-item.teacher {
      border-left-color: #34a853;
    }

    .message-item.student {
      border-left-color: #fbbc04;
    }

    .message-item.bank {
      border-left-color: #ea4335;
    }

    .message-meta {
      color: #aaa;
      font-size: 0.65rem;
      margin-top: 3px;
    }

    .message-count {
      color: #4285f4;
      font-weight: bold;
    }

    .algorithm-info {
      background: rgba(255, 255, 255, 0.1);
      padding: 10px;
      border-radius: 5px;
      margin-top: 15px;
      font-size: 0.7rem;
      line-height: 1.6;
    }

    .algorithm-info strong {
      color: #4285f4;
    }
  </style>
</head>
<body>
  <div class="loading" id="loading">Starting ticker...</div>
  <div class="error" id="error" style="display: none;"></div>
  
  <div class="ticker-wrapper" id="tickerWrapper" style="display: none;">
    <div class="ticker-container">
      <div class="ticker" id="ticker"></div>
    </div>
  </div>

  <div class="controls" id="controls">
    <div class="controls-header">
      <span>âš™ï¸ Controls</span>
      <button class="toggle-btn" onclick="toggleControls()">âˆ’</button>
    </div>
    <div class="controls-content">
      <div class="control-group">
        <label class="control-label">Scroll Speed</label>
        <input 
          type="range" 
          min="20" 
          max="200" 
          value="100" 
          class="speed-slider" 
          id="speedSlider"
          oninput="updateSpeed(this.value)"
        />
        <div class="speed-value" id="speedValue">Normal (100px/s)</div>
      </div>
      <div class="status" id="status">Initializing...</div>
    </div>
  </div>

  <div class="debug-panel" id="debugPanel">
    <h2>ğŸ” Message Debug Panel</h2>
    <div class="debug-grid">
      <div class="debug-column">
        <h3>Bank Messages (${BANK.length})</h3>
        <div class="message-list" id="bankList"></div>
      </div>
      <div class="debug-column">
        <h3>Teacher Messages (<span id="teacherCount">0</span>)</h3>
        <div class="message-list" id="teacherList"></div>
      </div>
      <div class="debug-column">
        <h3>Student Messages (<span id="studentCount">0</span>)</h3>
        <div class="message-list" id="studentList"></div>
      </div>
    </div>
    <div class="algorithm-info" id="algorithmInfo">
      <strong>ğŸ² Active Algorithm:</strong><br>
      Recent Buffer: <span id="bufferSize">0</span>/10 messages<br>
      Bank Deck: <span id="deckProgress">0/23</span> (will reshuffle when exhausted)<br>
      Teacher Probability: <span id="teacherProb">--</span>%
    </div>
  </div>

  <script>
    const API_URL = 'https://script.google.com/macros/s/AKfycbyOC6oa5z9tWfbJZssWvivMCtnToE4eEAZ-NFTOMS5lOvBqIyzyAwE9zBiu_gC-R62y/exec';

    // Hardcoded Bank Messages
    const BANK = [
      "Bring your ACE every day!",
      "Every day is a chance to learn something new!",
      "Together we achieve more",
      "Dream big, work hard, stay focused",
      "Choose kindness always",
      "Your future starts today",
      "Learning today, leading tomorrow",
      "Respect yourself, respect others, respect learning",
      "Excellence is our standard",
      "Be here, be ready, be respectful",
      "Small steps lead to big success",
      "Growth happens outside your comfort zone",
      "Celebrate progress, not perfection",
      "Your attitude determines your altitude",
      "Make today count",
      "We rise by lifting others",
      "The Mustang Way is our way",
      "Effort and attitude are everything",
      "Success is a journey, not a destination",
      "Maybe, just maybe, we will see YOU in the halls",
      "Here at the McGlynn, we support each other",
      "It's a GREAT day to be a Mustang",
      "The best day to plant a tree was 20 years ago. The 2nd best day is today."
    ];

    const EMOJIS = [
      "â­","ğŸ‰","ğŸ”¥","ğŸ‘","âœ…","ğŸ’™","ğŸŒŸ","âœ¨","ğŸ¾","ğŸ“£",
      "ğŸˆ","ğŸ¶","ğŸ˜","ğŸš€","ğŸ’¥","ğŸ¤©","ğŸ†","ğŸ’«","ğŸ“¢","ğŸ‘",
      "ğŸ˜","ğŸ’›","ğŸ­","ğŸ¯","ğŸ“","ğŸ“","ğŸ“š","âœï¸","ğŸ“–","ğŸ«",
      "ğŸ’","ğŸ’¡","ğŸŒˆ","âš¡","ğŸ¨","ğŸ…","ğŸŒº","ğŸ¦‹","ğŸŒ»","ğŸ",
      "ğŸ","ğŸª","ğŸ””","ğŸµ","ğŸ¦„"
    ];

    // State
    let teacherMessages = []; // {id, message, name, email, timestamp, timesShown: 0}
    let studentMessages = []; // {id, message, name, email, timestamp, shown: false}
    let currentSpeed = 100;
    let scrollPosition = 0;
    let animationFrameId = null;
    let lastFrameTime = null;
    let messageQueue = [];
    let lastPollTime = Date.now();
    let minBufferSize = 40; // Minimum messages in DOM (reduced for faster updates)
    let lastBufferCheck = 0; // Throttle buffer checks

    // NEW: Anti-repetition features
    let recentMessagesBuffer = []; // Track last 10 messages to avoid consecutive repeats
    let bankDeck = []; // Shuffled deck of bank messages
    let bankDeckIndex = 0; // Current position in deck

    function toggleControls() {
      const controls = document.getElementById('controls');
      const btn = controls.querySelector('.toggle-btn');
      controls.classList.toggle('minimized');
      btn.textContent = controls.classList.contains('minimized') ? '+' : 'âˆ’';
    }

    function updateSpeed(value) {
      currentSpeed = parseInt(value);
      const speedValue = document.getElementById('speedValue');
      
      let label = 'Normal';
      if (value < 70) label = 'Very Slow';
      else if (value < 90) label = 'Slow';
      else if (value > 130) label = 'Very Fast';
      else if (value > 110) label = 'Fast';
      
      speedValue.textContent = `${label} (${value}px/s)`;
    }

    function updateStatus(message, isFetching = false) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = isFetching ? 'status fetching' : 'status';
    }

    function updateDebugPanel() {
      // Update counts
      document.getElementById('teacherCount').textContent = teacherMessages.length;
      document.getElementById('studentCount').textContent = studentMessages.length;

      // Update bank list
      const bankList = document.getElementById('bankList');
      bankList.innerHTML = BANK.map(msg => `
        <div class="message-item bank">${msg}</div>
      `).join('');

      // Update teacher list
      const teacherList = document.getElementById('teacherList');
      if (teacherMessages.length === 0) {
        teacherList.innerHTML = '<div style="color: #999; padding: 10px;">No teacher messages loaded</div>';
      } else {
        teacherList.innerHTML = teacherMessages.map(t => `
          <div class="message-item teacher">
            <strong>${t.name}</strong>: ${t.message.substring(0, 80)}${t.message.length > 80 ? '...' : ''}
            <div class="message-meta">
              Shown: <span class="message-count">${t.timesShown}</span> times | 
              ${new Date(t.timestamp).toLocaleString()}
            </div>
          </div>
        `).join('');
      }

      // Update student list
      const studentList = document.getElementById('studentList');
      if (studentMessages.length === 0) {
        studentList.innerHTML = '<div style="color: #999; padding: 10px;">No student messages loaded</div>';
      } else {
        studentList.innerHTML = studentMessages.map(s => `
          <div class="message-item student">
            <strong>${s.name}</strong>: ${s.message.substring(0, 80)}${s.message.length > 80 ? '...' : ''}
            <div class="message-meta">
              ${s.shown ? 'âœ“ Already shown' : 'â—‹ Not shown yet'} | 
              ${new Date(s.timestamp).toLocaleString()}
            </div>
          </div>
        `).join('');
      }

      // Update algorithm info
      document.getElementById('bufferSize').textContent = recentMessagesBuffer.length;
      document.getElementById('deckProgress').textContent = `${bankDeckIndex}/${BANK.length}`;
      
      // Calculate current teacher probability
      const avgTimesShown = teacherMessages.length > 0 
        ? teacherMessages.reduce((sum, t) => sum + t.timesShown, 0) / teacherMessages.length 
        : 0;
      
      let teacherProb;
      if (teacherMessages.length === 1) {
        teacherProb = Math.max(0.10, 0.60 - (avgTimesShown * 0.10));
      } else if (teacherMessages.length <= 3) {
        teacherProb = Math.max(0.15, 0.60 - (avgTimesShown * 0.10));
      } else {
        teacherProb = Math.max(0.20, 0.60 - (avgTimesShown * 0.10));
      }
      
      document.getElementById('teacherProb').textContent = Math.round(teacherProb * 100);
    }

    // NEW: Shuffle bank deck (Fisher-Yates algorithm)
    function shuffleBankDeck() {
      bankDeck = [...BANK];
      for (let i = bankDeck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [bankDeck[i], bankDeck[j]] = [bankDeck[j], bankDeck[i]];
      }
      bankDeckIndex = 0;
      console.log('ğŸ”€ Bank deck shuffled - fresh rotation starting');
    }

    // NEW: Check if message is in recent buffer
    function isInRecentBuffer(messageText) {
      return recentMessagesBuffer.some(msg => msg === messageText);
    }

    // NEW: Add message to recent buffer
    function addToRecentBuffer(messageText) {
      recentMessagesBuffer.push(messageText);
      if (recentMessagesBuffer.length > 10) {
        recentMessagesBuffer.shift(); // Keep only last 10
      }
    }

    // Weighted probability algorithm with IMPROVEMENTS
    function getNextMessage() {
      const allTeachersShownOnce = teacherMessages.length === 0 || 
                                    teacherMessages.every(t => t.timesShown > 0);
      
      // Priority: All teachers must be shown at least once before any students
      if (!allTeachersShownOnce) {
        const unshownTeachers = teacherMessages.filter(t => t.timesShown === 0);
        return pickTeacherMessage(unshownTeachers);
      }
      
      // Calculate probabilities
      const totalSubmitted = teacherMessages.length + studentMessages.filter(s => !s.shown).length;
      
      // IMPROVEMENT #3: Dynamic teacher probability based on pool size
      const avgTimesShown = teacherMessages.length > 0 
        ? teacherMessages.reduce((sum, t) => sum + t.timesShown, 0) / teacherMessages.length 
        : 0;
      
      let teacherProb;
      if (teacherMessages.length === 1) {
        // Single teacher: max 10% to prevent overwhelming repetition
        teacherProb = Math.max(0.10, 0.60 - (avgTimesShown * 0.10));
      } else if (teacherMessages.length <= 3) {
        // Small pool: max 15%
        teacherProb = Math.max(0.15, 0.60 - (avgTimesShown * 0.10));
      } else {
        // Larger pool: original 20% minimum
        teacherProb = Math.max(0.20, 0.60 - (avgTimesShown * 0.10));
      }
      
      // Student probability: 30%
      const studentProb = 0.30;
      
      // Bank probability: 40% normally, 20% if 20+ submissions
      let bankProb = totalSubmitted >= 20 ? 0.20 : 0.40;
      
      // Adjust if no teachers or no students available
      if (teacherMessages.length === 0) teacherProb = 0;
      if (studentMessages.filter(s => !s.shown).length === 0) {
        // No students available, redistribute probability
        const remaining = studentProb;
        teacherProb += remaining * 0.5;
        bankProb += remaining * 0.5;
      }
      
      // Normalize probabilities
      const total = teacherProb + studentProb + bankProb;
      teacherProb /= total;
      const studentProbEnd = teacherProb + (studentProb / total);
      
      // Pick based on probability
      const rand = Math.random();
      
      if (rand < teacherProb && teacherMessages.length > 0) {
        return pickTeacherMessage(teacherMessages);
      } else if (rand < studentProbEnd && studentMessages.filter(s => !s.shown).length > 0) {
        return pickStudentMessage();
      } else {
        return pickBankMessage();
      }
    }

    // NEW: Get next message with buffer check to avoid consecutive repeats
    function getNextMessageWithBuffer() {
      let attempts = 0;
      let message;
      
      do {
        message = getNextMessage();
        attempts++;
      } while (isInRecentBuffer(message.text) && attempts < 20);
      
      // If we couldn't avoid buffer after 20 tries (very small pool), just use it
      // This prevents infinite loops
      return message;
    }

    function pickTeacherMessage(pool) {
      if (pool.length === 0) return pickBankMessage();
      
      // Weighted selection: prefer messages shown fewer times
      const maxShown = Math.max(...pool.map(t => t.timesShown));
      const weights = pool.map(t => (maxShown - t.timesShown + 1));
      const totalWeight = weights.reduce((a, b) => a + b, 0);
      
      let rand = Math.random() * totalWeight;
      for (let i = 0; i < pool.length; i++) {
        rand -= weights[i];
        if (rand <= 0) {
          pool[i].timesShown++;
          return { text: `${pool[i].message} - ${pool[i].name}`, type: 'teacher' };
        }
      }
      
      pool[0].timesShown++;
      return { text: `${pool[0].message} - ${pool[0].name}`, type: 'teacher' };
    }

    function pickStudentMessage() {
      const available = studentMessages.filter(s => !s.shown);
      if (available.length === 0) return pickBankMessage();
      
      const student = available[Math.floor(Math.random() * available.length)];
      student.shown = true;
      return { text: `${student.message} - ${student.name}`, type: 'student' };
    }

    // IMPROVEMENT #2: Bank deck rotation instead of pure random
    function pickBankMessage() {
      if (bankDeckIndex >= bankDeck.length) {
        shuffleBankDeck(); // Reshuffle when deck is exhausted
      }
      const message = bankDeck[bankDeckIndex++];
      return { text: message, type: 'bank' };
    }

    function pickEmoji() {
      return { text: EMOJIS[Math.floor(Math.random() * EMOJIS.length)], type: 'emoji' };
    }

    // Generate batch of messages with emojis between each message
    // IMPROVEMENT #1: Track messages in recent buffer
    function generateBatch(count = 40) {
      const batch = [];
      for (let i = 0; i < count; i++) {
        const msg = getNextMessageWithBuffer();
        batch.push(msg);
        addToRecentBuffer(msg.text); // Track in buffer
        batch.push(pickEmoji()); // Always add emoji after each message
      }
      return batch;
    }

    // Append messages to ticker
    function appendMessages(messages) {
      const ticker = document.getElementById('ticker');
      
      messages.forEach(msg => {
        const span = document.createElement('span');
        span.className = msg.type === 'emoji' ? 'item emoji' : 'item';
        span.textContent = msg.text;
        ticker.appendChild(span);
      });
    }

    // Continuous scroll animation
    function animateScroll(timestamp) {
      const ticker = document.getElementById('ticker');
      
      if (!lastFrameTime) {
        lastFrameTime = timestamp;
      }
      
      let deltaTime = (timestamp - lastFrameTime) / 1000;
      lastFrameTime = timestamp;
      
      // Cap deltaTime to prevent huge jumps after pauses (e.g., tab switch, OBS scene change)
      deltaTime = Math.min(deltaTime, 0.1); // Maximum 100ms per frame
      
      scrollPosition += currentSpeed * deltaTime;
      ticker.style.transform = `translateX(-${scrollPosition}px)`;
      
      cleanupOffscreenItems();
      
      // Throttle buffer check to every 200ms instead of every frame
      if (timestamp - lastBufferCheck > 200) {
        checkBuffer();
        lastBufferCheck = timestamp;
      }
      
      animationFrameId = requestAnimationFrame(animateScroll);
    }

    function cleanupOffscreenItems() {
      const ticker = document.getElementById('ticker');
      const children = ticker.children;
      
      // Remove items that are completely off the left side of the screen
      while (children.length > 0) {
        const firstChild = children[0];
        const rect = firstChild.getBoundingClientRect();
        
        // Check if item is more than 2000px off the left side
        if (rect.right < -2000) {
          // CRITICAL: Adjust scrollPosition by the width of the removed item
          // This prevents scrollPosition from growing infinitely
          const itemWidth = firstChild.offsetWidth;
          const marginRight = parseFloat(window.getComputedStyle(firstChild).marginRight) || 0;
          const totalWidth = itemWidth + marginRight;
          
          // Subtract the removed item's width from scroll position
          scrollPosition = Math.max(0, scrollPosition - totalWidth);
          
          ticker.removeChild(firstChild);
        } else {
          break; // Stop when we hit an item still visible
        }
      }
    }

    function checkBuffer() {
      const ticker = document.getElementById('ticker');
      const currentCount = ticker.children.length;
      
      // Only refill if buffer is actually low (prevents over-generation)
      if (currentCount < minBufferSize) {
        const needed = minBufferSize - currentCount + 20; // Add extra buffer
        const newMessages = generateBatch(Math.ceil(needed / 2)); // Each batch has message + emoji
        appendMessages(newMessages);
        
        console.log(`Buffer low (${currentCount}), added ${newMessages.length} items`);
      }
    }

    // Fetch initial messages from backend
    async function fetchInitial() {
      try {
        updateStatus('Loading messages...', true);
        const response = await fetch(`${API_URL}?action=getInitial&_=${Date.now()}`);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Load teacher messages
        if (data.teachers && data.teachers.length > 0) {
          teacherMessages = data.teachers.map(t => ({
            id: t.row,
            message: t.message,
            name: t.name,
            email: t.email,
            timestamp: new Date(t.timestamp),
            timesShown: 0
          }));
        }
        
        // Load student messages
        if (data.students && data.students.length > 0) {
          studentMessages = data.students.map(s => ({
            id: s.row,
            message: s.message,
            name: s.name,
            email: s.email,
            timestamp: new Date(s.timestamp),
            shown: false
          }));
        }
        
        lastPollTime = Date.now();
        
        const totalMessages = teacherMessages.length + studentMessages.length;
        updateStatus(`Loaded: ${teacherMessages.length} teachers, ${studentMessages.length} students`, false);
        
        console.log(`Loaded ${totalMessages} submissions from backend`);
        
        // Update debug panel
        updateDebugPanel();
        
      } catch (err) {
        console.error('Error fetching initial messages:', err);
        updateStatus('Using bank messages only', false);
      }
    }

    // Poll for new messages
    async function pollNewMessages() {
      try {
        const response = await fetch(`${API_URL}?action=getNew&since=${lastPollTime}&_=${Date.now()}`);
        
        if (!response.ok) {
          console.error(`Poll error: ${response.status}`);
          return;
        }
        
        const data = await response.json();
        
        let newCount = 0;
        
        // Add new teacher messages
        if (data.teachers && data.teachers.length > 0) {
          data.teachers.forEach(t => {
            teacherMessages.push({
              id: t.row,
              message: t.message,
              name: t.name,
              email: t.email,
              timestamp: new Date(t.timestamp),
              timesShown: 0
            });
            newCount++;
          });
          
          // ğŸš¨ FAST UPDATE: Clear buffer and regenerate to include new teachers
          const ticker = document.getElementById('ticker');
          const currentBufferSize = ticker.children.length;
          
          // Only clear if buffer is large (prevents flicker during normal operation)
          if (currentBufferSize > 40) {
            console.log('ğŸ”¥ NEW TEACHER DETECTED - Forcing buffer refresh');
            ticker.innerHTML = ''; // Clear old messages
            recentMessagesBuffer = []; // Clear recent buffer for fresh start
            const freshBatch = generateBatch(40); // Generate fresh batch with new teacher
            appendMessages(freshBatch);
            console.log('âœ… Buffer refreshed - new teacher will appear within 30 seconds');
          }
        }
        
        // Add new student messages
        if (data.students && data.students.length > 0) {
          data.students.forEach(s => {
            studentMessages.push({
              id: s.row,
              message: s.message,
              name: s.name,
              email: s.email,
              timestamp: new Date(s.timestamp),
              shown: false
            });
            newCount++;
          });
          
          // ğŸš¨ FAST UPDATE: Refresh buffer for new students (if all teachers shown)
          const allTeachersShown = teacherMessages.length === 0 || 
                                   teacherMessages.every(t => t.timesShown > 0);
          
          if (allTeachersShown) {
            const ticker = document.getElementById('ticker');
            const currentBufferSize = ticker.children.length;
            
            if (currentBufferSize > 40) {
              console.log('ğŸ”¥ NEW STUDENT DETECTED - Forcing buffer refresh');
              ticker.innerHTML = '';
              recentMessagesBuffer = []; // Clear recent buffer for fresh start
              const freshBatch = generateBatch(40);
              appendMessages(freshBatch);
              console.log('âœ… Buffer refreshed - new student will appear within 30 seconds');
            }
          } else {
            console.log('âš ï¸ New student added but waiting for all teachers to be shown first');
          }
        }
        
        lastPollTime = Date.now();
        
        if (newCount > 0) {
          console.log(`Polled ${newCount} new messages`);
          updateStatus(`+${newCount} new â€¢ ${teacherMessages.length}T ${studentMessages.length}S`, false);
          
          // Update debug panel
          updateDebugPanel();
        }
        
      } catch (err) {
        console.error('Error polling new messages:', err);
      }
    }

    // Initialize
    async function init() {
      const loading = document.getElementById('loading');
      const error = document.getElementById('error');
      const tickerWrapper = document.getElementById('tickerWrapper');

      try {
        // Initialize bank deck
        shuffleBankDeck();
        console.log('âœ… Bank deck initialized and shuffled');
        
        // Fetch initial messages from backend
        await fetchInitial();
        
        // Generate initial batch
        const initialBatch = generateBatch(80);
        appendMessages(initialBatch);
        
        // Show ticker
        loading.style.display = 'none';
        tickerWrapper.style.display = 'block';
        
        // Start continuous scroll
        animationFrameId = requestAnimationFrame(animateScroll);
        
        // Poll for new messages every 10 seconds (faster updates for live show)
        setInterval(pollNewMessages, 10000);
        
        // Update debug panel every 5 seconds to show timesShown changes
        setInterval(updateDebugPanel, 5000);
        
        updateStatus(`Ready â€¢ ${teacherMessages.length}T ${studentMessages.length}S`, false);
        
        // Initial debug panel update
        updateDebugPanel();
        
      } catch (err) {
        console.error('Initialization error:', err);
        loading.style.display = 'none';
        error.textContent = `Error: ${err.message}\n\nTicker will run with bank messages only.`;
        error.style.display = 'block';
        
        // Initialize bank deck even in error case
        shuffleBankDeck();
        
        // Still start with bank messages
        const initialBatch = generateBatch(80);
        appendMessages(initialBatch);
        tickerWrapper.style.display = 'block';
        animationFrameId = requestAnimationFrame(animateScroll);
        
        // Update debug panel to show bank messages
        updateDebugPanel();
      }
    }

    // Start on page load
    window.addEventListener('load', init);

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
    });
  </script>
</body>
</html>
